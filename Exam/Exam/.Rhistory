for(i in 1:B){
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
}
bootmat <- bootmat[-1]
mlevec <- apply(bootmat, 2, mle)
StdE <- sd(mlevec)
B=0
bootmat <- data.frame(nrow=length(y))
for(i in 1:B){
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
}
B=1
bootmat <- data.frame(nrow=length(y))
for(i in 1:B){
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
}
bootmat <- bootmat[-1]
mlevec <- apply(bootmat, 2, mle)
StdE <- sd(mlevec)
return(StdE)
bootmat <- data.frame(nrow=length(y))
for(i in 1:B){
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
}
bootmat <- bootmat[-1]
View(bootmat)
mlevec <- apply(bootmat, 2, mle)
StdE <- sd(mlevec)
B=2
bootmat <- data.frame(nrow=length(y))
for(i in 1:B){
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
}
bootmat <- bootmat[-1]
bootmat <- matrix(nrow=length(y))
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
bootmat <- bootmat[-1]
is.integer(-1)
is.integer(0)
is.integer(1)
is.integer(3)
is.integer()
is.integer(1)
is.wholenumber(5)
check.integer(1)
3.3%%1
bootmat <- data.frame(nrow=length(y))
B=1
for(i in 1:B){
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
}
bootmat <- bootmat[-1]
if(B==1){t(bootmat)}
mlevec <- apply(bootmat, 2, mle)
StdE <- sd(mlevec)
return(StdE)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
#Test some data to run through things
y <- c(5,2,8,3,9,2)
#test the standardError and confirm it gives correct results
standardError(y,"basic")
sqrt(mle(y)/length(y))
standardError(y,"bootstrapped",1)
standardError(y,"bootstrapped",4)
standardError(y,"bootstrapped",5)
standardError(y,"bootstrapped",1000)
standardError(y,"bootstrapped")
standardError(y,"bootstrapped",1)
standardError(y,"bootstrapped",1)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
standardError(y,"bootstrapped",1)
standardError(y,"bootstrapped",1)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
standardError(y,"bootstrapped")
standardError(y,"bootstrapped",1)
bootmat <- data.frame(nrow=length(y))
bootmat <- cbind(bootmat,sample(y,length(y),replace = T))
bootmat <- bootmat[-1]
mlevec <- mle(bootmat)
mlevec
mle(bootmat)
length(bootmat)
standardError(y,"bootstrapped",1)
sd(mle(y))
#test the standardError and confirm it gives correct results
standardError(y,"basic")
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
#test the standardError and confirm it gives correct results
standardError(y,"basic")
sqrt(mle(y)/length(y))
standardError(y,"bootstrapped",1)
standardError(y,"bootstrapped",2)
standardError(y,"bootstrapped",1)
standardError(y,"bootstrapped")
standardError(y,"bootstrapped")
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
#test the standardError and confirm it gives correct results
standardError(y,"basic")
standardError(y,"bootstrapped")
standardError(y,"bootstrapped",1)
standardError(y,"bootstrapped",.5)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
standardError(y,"bootstrapped",.5)
standardError(y,"bootstrapped",1)
standardError(y,"bootstrapped",100)
standardError(y,"bootstrapped",1000)
standardError(y,"bootstrapped",10000)
standardError(y,"bootstrapped",10000)
standardError(y,"bootstrapped",100)
lapply(y,%%1)
lapply(y,x%%1==0)
lapply(y,y%%1==0)
lapply(y,>0)
lapply(y,'>0')
lapply(y,function(x) ifelse(x>0,1,0)))
lapply(y, function(x){ifelse(x>0,1,0)}))
lapply(y, function(x){ifelse(x>0,1,0)})
lapply(y, function(x){ifelse(x>0,T,F)})
lapply(y, function(x){ifelse(x>0,T,F)})
lapply(y, function(x){ifelse(x>0,T,F)})
#Test some data to run through things
y <- c(-5,2,8,3,9,2)
lapply(y, function(x){ifelse(x>0,T,F)})
TRUE == lapply(y, function(x){ifelse(x>0,T,F)})
F == lapply(y, function(x){ifelse(x>0,T,F)})
#Test some data to run through things
y <- c(5,2,8,3,9,2)
positive <- mean(lapply(y, function(x){ifelse(x>0,T,F)}))==1
positive <- lapply(y, function(x){ifelse(x>0,T,F)})
positive
positive <- sum(lapply(y, function(x){ifelse(x>0,T,F)}))
all(lapply(y, function(x){ifelse(x>0,T,F)}))
all(sapply(y, function(x){ifelse(x>0,T,F)}))
#Test some data to run through things
y <- c(-5,2,8,3,9,2)
all(sapply(y, function(x){ifelse(x>0,T,F)}))
#Test some data to run through things
y <- c(5,2,8,3,9,2)
all(sapply(y, function(x){ifelse(x>0,T,F)}))
sapply(y, function(x){ifelse(x%%1==0,T,F)})
#Test some data to run through things
y <- c(5.5,2,8,3,9,2)
sapply(y, function(x){ifelse(x%%1==0,T,F)})
#Test some data to run through things
y <- c(0,2,8,3,9,2)
positive <- all(sapply(y, function(x){ifelse(x>0,T,F)}))
if(!positive){stop("The observations must all be positive")}
positive <- all(sapply(y, function(x){ifelse(x>=0,T,F)}))
if(!positive){stop("The observations must all be positive")}
integer <- all(sapply(y, function(x){ifelse(x%%1==0,T,F)}))
if(!integer){stop("The observations must all be integers")}
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
#Test some data to run through things
y <- c(0,2,8,3,9,2)
mle(y)
logLik(c(5,2,8,3,9,2),5)
logLik(y,mle(y))
factorial(y)
a <- factorial(y)
b <- log(a)
b
c <- sum(b)
c
#Test some data to run through things
y <- c(8,5,100,6,9,75,15,26,34,33,29,46,80)
mle(y)
logLik(y,mle(y))
#test the standardError and confirm it gives correct results
standardError(y,"basic")
sqrt(mle(y)/length(y))
#Test the bootstrap
standardError(y,"bootstrapped",100)
standardError(y,"bootstrapped",1)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
#Test some data to run through things
y <- c(8,5,100,6,9,75,15,26,34,33,29,46,80)
#Test the final output
estimatePois(y,"basic")
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
#Test the final output
estimatePois(y,"basic")
estimatePois(y,"bootstrapped",1000)
document(current.code)
document(current.code)
test(current.code)
??mle
??mle()
?mle()
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
?mle()
?logLik()
?standardError()
?estimatePois()
?PoisMLE
dpois(100,4)
rpois(1000,80)
#Test some data to run through things
set.seed(1625)
y <- rpois(1000,80)
mle(y)
logLik(y,mle(y))
#test the standardError and confirm it gives correct results
standardError(y,"basic")
sqrt(mle(y)/length(y))
#Test the bootstrap
standardError(y,"bootstrapped",100)
standardError(y,"bootstrapped",.8)
standardError(y,"bootstrapped",1)
#Test the final output
estimatePois(y,"basic")
estimatePois(y,"bootstrapped",1000)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
?estimatePois()
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
#Test the help functions
?mle()
#Test some data to run through things
set.seed(1625)
y <- rpois(1000,80)
mle(y)
logLik(y,mle(y))
?logLik()
?standardError()
?estimatePois()
?PoisMLE
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
?setAs
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
?dpois
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
lambda.hat <- mle(y)
lambda.vec <- seq(lambda.hat-2.5,lambda.hat+2.5,by=.1)
lambda.vec
ll_vec <- logLik(y,lambda_vec)
lambda_hat <- mle(y)
lambda_vec <- seq(lambda.hat-2.5,lambda.hat+2.5,by=.01)
ll_vec <- logLik(y,lambda_vec)
ll_vec
ll_vec <- e^(logLik(y,lambda_vec))
ll_vec <- exp(logLik(y,lambda_vec))
ll_vec
ll_vec(1)
ll_vec[1]
ll_vec <- logLik(y,lambda_vec)
ggplot() + geom_point(aes(lambda_vec,ll_vec))
library(ggplot2)
ggplot() + geom_point(aes(lambda_vec,ll_vec))
ggplot() + geom_point(aes(lambda_vec,ll_vec)) + labs(x = "Lambda", y = "Log Likelihood")
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
plotMLE(y,"basic")
current.code <- as.package("exam")
load_all(current.code)
#test the plot
plotMLE(y,"basic")
current.code <- as.package("exam")
load_all(current.code)
#test the plot
plotMLE(y,"basic")
plotMLE(y,"boostrapped",1000)
plotMLE(y,"bootstrapped",1000)
plotMLE(y,"bootstrapped",100)
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
#test the plot
plotMLE(y,"basic")
plotMLE(y,"bootstrapped",100)
?plotMLE
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
#test the plot
plotMLE(y,"basic",2.5)
#test the plot
plotMLE(y,"basic",lambda_width = 2.5)
plotMLE(y,"bootstrapped",100, 5)
#test the plot
plotMLE(y,"basic")
current.code <- as.package("exam")
load_all(current.code)
#test the plot
plotMLE(y,"basic")
plotMLE(y,"bootstrapped")
#Load libraries necessary for the exam
library(devtools)
library(roxygen2)
#Set the exam wd
setwd("C:/Users/jordo/Documents/GitHub/AppliedStatisticalProgramming2022/exam/")
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
#Test some data to run through things
set.seed(1625)
y <- rpois(1000,80)
mle(y)
logLik(y,mle(y))
#test the standardError and confirm it gives correct results
standardError(y,"basic")
sqrt(mle(y)/length(y))
#Test the bootstrap
standardError(y,"bootstrapped",100)
standardError(y,"bootstrapped",.8)
standardError(y,"bootstrapped",1)
#Test the final output
estimatePois(y,"basic")
estimatePois(y,"bootstrapped",1000)
#test the plot
plotMLE(y,"basic")
plotMLE(y,"bootstrapped")
plotMLE(y,"bootstrapped",lambda_width = 5)
#Test the help functions
?mle()
?logLik()
?standardError()
?estimatePois()
?PoisMLE
?plotMLE
y2 <- rpois(25,6)
mle(y2)
logLik(y)
logLik(y2)
standardError(y2)
standardError(y2, "basic")
standardError(y2, "first")
standardError(y2, "basic")
sqrt(mle(y2)/length(y2))
standardError(y2,"bootstrapped")
estimatePois(y,"bootstrapped")
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
#Test some data to run through things
set.seed(1625)
y <- rpois(1000,80)
set.seed(1625)
y2 <- rpois(25,6)
mle(y)
mle(y2)
logLik(y)
logLik(y2)
#test the standardError and confirm it gives correct results
standardError(y,"basic")
sqrt(mle(y)/length(y))
standardError(y2, "basic")
sqrt(mle(y2)/length(y2))
#Test the bootstrap
standardError(y,"bootstrapped",100)
standardError(y2,"bootstrapped")
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
standardError(y,"booted")
standardError(y2,"bootstrapped")
standardError(y2,"bootstrapped")
#Test the bootstrap
standardError(y,"bootstrapped",100)
standardError(y2, "basic")
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
standardError(y,"booted")
#Test the bootstrap
standardError(y,"bootstrapped",100)
standardError(y2,"bootstrapped")
#Test a few that should not work
standardError(y,"bootstrapped",.8)
standardError(y,"bootstrapped",1)
standardError(y,"booted")
#Test the final output
estimatePois(y,"basic")
estimatePois(y,"bootstrapped",1000)
estimatePois(y2,"basic")
estimatePois(y2,"bootstrapped")
plotMLE(y,"booted")
plotMLE(y2,"basic")
plotMLE(y2,"bootstrapped")
plotMLE(y2,"bootstrapped", lambda_width = 1)
?plotMLE
library(devtools)
library(roxygen2)
#Set the exam wd
setwd("C:/Users/jordo/Documents/GitHub/AppliedStatisticalProgramming2022/exam/")
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
build(current.code)
build()
build("C:/Users/jordo/Documents/GitHub/AppliedStatisticalProgramming2022/exam/exam")
library(devtools)
library(roxygen2)
#Set the exam wd
setwd("C:/Users/jordo/Documents/GitHub/AppliedStatisticalProgramming2022/exam/")
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
#Load libraries necessary for the exam
library(devtools)
library(roxygen2)
#Set the exam wd
setwd("C:/Users/jordo/Documents/GitHub/AppliedStatisticalProgramming2022/exam/")
#Verify the package and testing
current.code <- as.package("exam")
load_all(current.code)
document(current.code)
check(current.code)
#Test some data to run through things
set.seed(1625)
y <- rpois(1000,80)
set.seed(1625)
y2 <- rpois(25,6)
mle(y)
mle(y2)
logLik(y)
logLik(y2)
#test the standardError and confirm it gives correct results
standardError(y,"basic")
sqrt(mle(y)/length(y))
standardError(y2, "basic")
sqrt(mle(y2)/length(y2))
#Test the bootstrap
standardError(y,"bootstrapped",100)
standardError(y2,"bootstrapped")
#Test a few that should not work
standardError(y,"bootstrapped",.8)
standardError(y,"bootstrapped",1)
standardError(y,"booted")
#Test the final output
estimatePois(y,"basic")
estimatePois(y,"bootstrapped",1000)
estimatePois(y2,"basic")
estimatePois(y2,"bootstrapped")
#test the plot
plotMLE(y,"basic")
plotMLE(y,"bootstrapped",lambda_width = 5)
plotMLE(y2,"basic")
plotMLE(y2,"bootstrapped", lambda_width = 1)
#Test the help functions
?mle()
?logLik()
?standardError()
?estimatePois()
?PoisMLE
?plotMLE
